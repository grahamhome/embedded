/*
 * Servo Driver 2.0
 * Designed, written, and tested by Graham Home and Karishma Reddy
 * Completed 11/17/15
 */
#include <cstdlib>
#include <iostream>
#include <stdint.h>
#include <pthread.h>
#include <sys/mman.h>
#include <unistd.h>
#include <map>
#include <hw/inout.h>
#include <sys/neutrino.h>
#include <stdio.h>

const static int DATA_BASE_ADDRESS = 0x280; //Address of the data acquisition bus
const static int DATA_PORT_A = DATA_BASE_ADDRESS + 0x08; //Address of register for Digital I/O Port A
const static int DATA_PORT_B = DATA_BASE_ADDRESS + 0x09; //Address of register for Digital I/O Port B
const static int DIOCTR = DATA_BASE_ADDRESS + 0x0B; //Address of control register for DIO Ports A & B

pthread_mutex_t mvMutex; //Mutex for move function

int lastStep; //Variable for turn-taking
pthread_mutex_t stepMutex; //Mutex for step variable

//A structure to hold a message, which contains a timer pulse.
typedef struct {
		struct _pulse pulse;
} MessageT;

//A 20ms period square wave generator. Signals the calling thread with a unique pulse at the end of each period and duty cycle.
class SquareWave {

	int t1_code; //Indicates that a pulse was generated by timer 1
	int t2_code; //Indicates that a pulse was generated by timer 2

	//Timer id and configuration variables
	timer_t timerid1;
	timer_t timerid2;
	struct itimerspec timer1;
	struct itimerspec timer2;

	int coid; //Channel connection id

public:

	//Channel ID
	int chid;

	//Null constructor so C++ interpreter will leave me alone
	SquareWave() {}

	//Constructor
	SquareWave(int chan) {

		//Set channel id
		chid = chan;

		//Initialize timer codes
		t1_code = 1;
		t2_code = 2;

		//Set clock
		setClock();

		//Create a connection
		coid = ConnectAttach(0, 0, chid, 0, 0);
		if (coid == -1) {
			std::cout << "Error: Couldn't attach" << std::endl;
		}
	}

	//Starts generating the square wave. Takes a double which indicates the length of the duty cycle in ms.
	void doTheWave(double duty) {
		struct sigevent event1;
		struct sigevent event2;

		//Setup pulse event 1
		SIGEV_PULSE_INIT (&event1, coid, SIGEV_PULSE_PRIO_INHERIT, t1_code, 0);

		//Setup pulse event 2
		SIGEV_PULSE_INIT (&event2, coid, SIGEV_PULSE_PRIO_INHERIT, t2_code, 0);

		//Create timers & bind to events
		if ((timer_create(CLOCK_REALTIME, &event1, &timerid1) == -1) || (timer_create(CLOCK_REALTIME, &event2, &timerid2) == -1)) {
			std::cout << "Error: Couldn't create timer" << std::endl;
		} else {
			//Setup timer 1
			timer1.it_value.tv_sec = 0;
			timer1.it_value.tv_nsec = 1;
			timer1.it_interval.tv_sec = 0;
			timer1.it_interval.tv_nsec = 20000000; //20 ms

			//Setup timer 2
			timer2.it_value.tv_sec = 0;
			timer2.it_value.tv_nsec = duty*1000000; //Convert duty from ms to nanoseconds
			timer2.it_interval.tv_sec = 0;
			timer2.it_interval.tv_nsec = 0;

			//Start timer 1
			timer_settime(timerid1, 0, &timer1, NULL);
		}
	}

	//Stops generation of the square wave
	void stop() {
		//Setup timers to be inactive
		timer1.it_value.tv_sec = 0;
		timer1.it_value.tv_nsec = 0;
		timer1.it_interval.tv_sec = 0;
		timer1.it_interval.tv_nsec = 0;
		timer2.it_value.tv_sec = 0;
		timer2.it_value.tv_nsec = 0;
		timer2.it_interval.tv_sec = 0;
		timer2.it_interval.tv_nsec = 0;

		//"Start" timers (actually stops them)
		timer_settime(timerid1, 0, &timer1, NULL);
		timer_settime(timerid2, 0, &timer2, NULL);

	}

	void gotPeriodPulse() {
		//Start timer 2
		timer_settime(timerid2, 0, &timer2, NULL);
	}

	void setClock() {
		struct _clockperiod clkper;
		clkper.fract = 0;
		clkper.nsec = 10000; //0.01 millisecond
		ClockPeriod(CLOCK_REALTIME, &clkper, NULL, NULL);
	}
};

//Encapsulates information needed to control a servo motor.
class Servo {
	uintptr_t ctrlReg; //The control register for the port which the servo is connected to
	uintptr_t outputPort; //The port which the servo is connected to
	int high; //Mask needed to set the servo's pin high
	int low; //Mask needed to set the servo's pin low
	int *recipes; //To be initialized to the servo's recipe list
	char cmd;
	pthread_mutex_t cmdMutex; //Mutex for command variable
	pthread_mutexattr_t mutexAttr; //Mutex attribute variable
	int rIndex; //The current index of the recipe list
	int sIndex; //The index used to mark the start of a recipe loop
	int lCount; //The counter used to indicate the number of iterations left in a recipe loop
	bool rActive; //Indicates whether or not the servo is currently executing a recipe or has reached the end of the recipe
	bool rPaused; //Indicates whether or not the servo is paused
	std::map<int, double> pValues; //Position values
	int curPos; //The current position of the servo
	SquareWave sw; //A square wave generator
	MessageT msg; //Message for square wave generator pulse
	int chid; //Channel for square wave generator pulse
	int port; //The port index, used to identify the servo for turn-taking
	int wait; //Time the servo must wait before executing the next recipe command

public:
	Servo(int h, int port, int* r, int ch) {
		//Initialize high & low bitmasks
		high = h;
		low = ~high;

		//Initialize output port controller
		ctrlReg = mmap_device_io(1, DIOCTR); //MMap control register
		if (ctrlReg == MAP_DEVICE_FAILED) {
			std::cout << "Error: Failed to memory map servo output port control register" << std::endl;
		}
		//Set Ports A & B to output mode
		out8(ctrlReg, 0x00);

		//Initialize servo output port
		outputPort = mmap_device_io(1, port); //MMap port
		if (outputPort == MAP_DEVICE_FAILED) {
			std::cout << "Error: Failed to memory map servo output port" << std::endl;
		}

		//Initialize command variable
		cmd = 'n';

		//Initialize command mutex
		pthread_mutexattr_init(&mutexAttr); //Initialize mutex attribute variable
		pthread_mutexattr_settype(&mutexAttr, PTHREAD_MUTEX_ERRORCHECK); //Set our mutex attribute to error-checking type
		pthread_mutex_init(&cmdMutex, &mutexAttr); //Initialize command mutex to be error-checking

		//Initialize recipe list
		int opcode = 1;
		int counter = 0;
		while (opcode != 0) {
			opcode = r[counter+1]; //Skip first element (bug)
			counter++;
		}
		recipes = new int[counter];
		for (int i=0; i<counter; i++) {
			recipes[i] = r[i+1]; //Skip first element (bug)
		}

		//Initialize recipe indices
		rIndex = 0;
		sIndex = 0;
		lCount = 0;
		rActive = true;
		rPaused = false;
		curPos = 0;

		//Initialize position values to time constants needed to move the servo to marked positions
		pValues[0] = 0.388;
		pValues[1] = 0.7384;
		pValues[2] = 1.0888;
		pValues[3] = 1.4392;
		pValues[4] = 1.7896;
		pValues[5] = 2.14;

		chid = ch;

		wait = 0;

		//Create square wave generators
		sw = SquareWave(chid);

	}

	//Reads and resets the mutex-protected command variable
	char getCmd() {
		int result = pthread_mutex_trylock(&cmdMutex);
		while (result != 0) {
			result = pthread_mutex_trylock(&cmdMutex);
		}
		char val = cmd;
		cmd = 'n';
		result = pthread_mutex_unlock(&cmdMutex);
		while (result != 0) {
			result = pthread_mutex_unlock(&cmdMutex);
		}
		return val;
	}

	//Sets the mutex-protected command variable
	void setCmd(char newCmd) {
		int result = pthread_mutex_trylock(&cmdMutex);
		while (result != 0) {
			result = pthread_mutex_trylock(&cmdMutex);
		}
		cmd = (char)newCmd;
		result = pthread_mutex_unlock(&cmdMutex);
		while (result != 0) {
			result = pthread_mutex_unlock(&cmdMutex);
		}
	}

	//Executes the override command if one exists, otherwise executes the next step in the servo's recipe
	void step(){
		//Get turn-taking variable mutex
		int result = pthread_mutex_trylock(&stepMutex);
		while (result != 0) {
			result = pthread_mutex_trylock(&stepMutex);
		}
		if (lastStep != port) { //Don't take 2 turns
			lastStep = port;

			char nextCmd = getCmd();
			if ((nextCmd != 'n') && (nextCmd != 'N')) {
				switch (nextCmd) {
					case ('P'):
					case ('p'):
						rPaused = true;
						break;
					case ('C'):
					case ('c'):
						rPaused = false;
						break;
					case ('R'):
					case ('r'):
						if (rPaused) {
							if (curPos > 0) {
								move(curPos-1);
							} else {
								move(5);
							}
						}
						break;
					case ('L'):
					case ('l'):
						if (rPaused) {
							if (curPos < 5) {
								move(curPos+1);
							} else {
								move(0);
							}
						}
						break;
					case ('B'):
					case ('b'):
						rIndex = 0;
						sIndex = 0;
						lCount = 0;
						wait = 0;
						rPaused = false;
						rActive = true;
						break;
				}
			} else {
				parse();
			}
		}
		//Release turn-taking variable mutex
		result = pthread_mutex_unlock(&stepMutex);
		while (result != 0) {
			result = pthread_mutex_unlock(&stepMutex);
		}
	}

	//Executes the next step in the servo's recipe
	void parse() {
		if (rActive && !rPaused){
			if (wait < 0) {
				wait--;
				usleep(100000); //Sleep for 1/10 sec
			} else {
				int opcode = recipes[rIndex];
				int op = (opcode >> 5) & 0x07;
				int arg = (opcode & 0x1F);
				switch (op) {
					case (1):
						if (arg >= 0) {
							move(arg);
						}
						rIndex++;
						break;
					case (2):
						wait = arg;
						rIndex++;
						break;
					case (4):
						lCount = arg;
						rIndex++;
						sIndex = rIndex;
						break;
					case (5):
						if (lCount > 0) {
							rIndex = sIndex;
							lCount--;
						} else {
							rIndex++;
						}
						break;
					case (0) :
						rActive = false;
						break;
				}
			}
		}
	}

	//Moves the servo to the position specified in the parameter.
	void move(int pos) {
		//Get the move mutex
		int result = pthread_mutex_trylock(&mvMutex);
		while (result != 0) {
			result = pthread_mutex_trylock(&mvMutex);
		}
		int count = 0;
		sw.doTheWave(pValues[pos]);
		while (count < 40) {
			MsgReceive(sw.chid, &msg, sizeof(msg), NULL);
			if (msg.pulse.code == 1) {
				//Start duty cycle timer
				sw.gotPeriodPulse();

				//Set pin high
				out8(outputPort, high);

			} else {

				//Set pin low
				out8(outputPort, low); //Bitmask the current value with the 'pin low' value and write it to the port

				//Increment counter
				count++;
			}
		}
		//Stop the square wave generator
		sw.stop();

		//Update current position
		curPos = pos;

		//Release move mutex
		result = pthread_mutex_unlock(&mvMutex);
		while (result != 0) {
			result = pthread_mutex_unlock(&mvMutex);
		}
	}
};

//Method run by servo driver thread
void *drive(void *servo) {
	while(1) {
		(*(Servo*)servo).step();
	}
}

int main(int argc, char *argv[]) {
	int privity_err = ThreadCtl(_NTO_TCTL_IO, NULL);
	if (privity_err == -1) {
		std::cout << "Error: Can't get root permission" << std::endl;
		return EXIT_FAILURE;
	} else {

		//Initialize move mutex
		pthread_mutexattr_t mutexAttr; //Mutex attribute variable
		pthread_mutexattr_init(&mutexAttr); //Initialize mutex attribute variable
		pthread_mutexattr_settype(&mutexAttr, PTHREAD_MUTEX_ERRORCHECK); //Set our mutex attribute to error-checking type
		pthread_mutex_init(&mvMutex, &mutexAttr); //Initialize move function mutex to be error-checking
		pthread_mutex_init(&stepMutex, &mutexAttr); //Initialize step variable mutex to be error-checking

		//Test recipes - recipe r1 includes all test snippets from project instructions

		//NOTE: First item will be ignored (unknown bug
		//prevents it from being copied properly),
		//actual recipes start at index 1

		int r1[20] = {0x20, 0x20, 0x25, 0x20, 0x23, 0x80, 0x21, 0x24, 0xa0, 0x20, 0x22, 0x40, 0x23, 0x22, 0x23, 0x5f, 0x5f, 0x5f, 0x24, 0x00};

		int r2[16] = {0x20, 0x82, 0x20, 0x25, 0xa0, 0x85, 0x20, 0x21, 0x22, 0xa0, 0x20, 0x21, 0x23, 0x24, 0x25, 0x00};

		//Create channel
		int chid = ChannelCreate(0);
		if (chid == -1) {
			std::cout << "Error: Couldn't create channel" << std::endl;
		}
		Servo s1 = Servo(0x01, DATA_PORT_A, r1, chid);
		Servo s2 = Servo(0x01, DATA_PORT_B, r2, chid);
		pthread_create(NULL, NULL, drive, (void *) &s1);
		pthread_create(NULL, NULL, drive, (void *) &s2);
		std::cout << "Please type your override commands below. Override commands must consist of 2 letters terminated with a carriage return." << std::endl;
		std::cout << ">";
		while(1) {
			int input[3] = {0, 0, 0};
			for (int i=0; i<3; i++) {
				input[i] = getchar();
			}
			if ((input[0] != 10) &&(input[1] != 10) && input[2] == 10) { //Check for premature CR
				s1.setCmd(input[0]);
				s2.setCmd(input[1]);
			}
			std::cout << ">";
		}
	}
}
